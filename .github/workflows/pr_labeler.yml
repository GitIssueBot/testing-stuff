name: "Pull Request Automation"
on:
  pull_request_target:
    types: ["opened", "synchronize", "reopened", "edited", "labeled", "unlabeled"]

jobs:
  label:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/labeler@v3
        with:
          repo-token: "${{ secrets.GITHUB_TOKEN }}"

  validate:
    runs-on: ubuntu-latest
    needs: label
    steps:
      - uses: actions/github-script@v3.1.0
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const number = context.payload.pull_request.number;

            // Get current PR data (the data in the context might be outdated)
            const { data: pr } = await github.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: number
            });

            let allowed_targets = ["maintenance", "devel", "staging/maintenance", "staging/devel"];
            let forbidden_sources = ["master", "maintenance", "devel"];
            const problem_label = "needs some work";
            const approve_label = "approved";

            let labels = [];
            let setLabels = false;
            pr.labels.forEach(label => { labels.push(label.name) });
            core.info("PR labels are " + labels.join(", "));

            if (!labels.includes('approved')) {
              if (labels.includes('docs') || labels.includes('ci/cd') || labels.includes('meta')) {
                allowed_targets.unshift("main");
                allowed_targets.unshift("master");
              }

              const source = context.payload.pull_request.head.ref;
              const target = context.payload.pull_request.base.ref;
              core.info("PR source is " + source);
              core.info("PR target is " + target);

              let problems = [];

              if (pr.body.trim() === "") {
                problems.push("Your PR does have an empty description. Please explain what "
                            + "your PR does, how you've tested your changes, etc.");
                core.error("PR has an empty description");
              }

              if (forbidden_sources.includes(source)) {
                problems.push("Your PR's source branch `" + source + "` is among the "
                            + "forbidden source branches: " + blacklisted_sources.join(", ")
                            + ". Please always create PRs from a custom branch in your "
                            + "repository to avoid accidental commits making it into "
                            + "your PR.");
                core.error("PR's source branch is among the forbidden source branches");
              }

              if (!allowed_targets.includes(target)) {
                problems.push("Your PR's target branch `" + target + "` is not among the "
                            + "allowed target branches: " + allowed_targets.join(", ")
                            + ". Please only create your PRs against these.");
                core.error("PR's target branch is not among the allowed target branches");
              }

              if (problems.length) {
                // Problems were detected
            
                if (!labels.includes(problem_label)) {
                  // Not yet labeled, post comment and label accordingly
                  let comment = "Hi @" + context.payload.pull_request.user.login + ",\n\n"
                              + "Thank you for your contribution! Sadly it looks like there "
                              + "is something wrong with this PR from your branch `"
                              + source + " to OctoPrint:" + target + ":\n\n";
  
                  problems.forEach(problem => {
                    comment += "  * " + problem + "\n";
                  });
  
                  comment += "\n\nPlease take a look at the "
                           + "[section on PRs in the Contribution Guidelines](https://github.com/OctoPrint/OctoPrint/blob/master/CONTRIBUTING.md#pull-requests) "
                           + "and make sure that your PR follows them. Thank you!";
  
                  github.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: number,
                    body: comment
                  });
  
                  github.issues.addLabels({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: number,
                    labels: [problem_label]
                  });
                }

                core.setFailed("This PR has not passed validation");
              } else {
                let setLabels = false;

                if (labels.includes(problem_label) {
                  labels = labels.filter(label => label !== problem_label);
                  setLabels = true;
                }
                if (!labels.includes(approve_label) {
                  labels.push(approve_label);
                  setLabels = true;
                }

                if (setLabels) {
                  github.issues.setLabels({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: number,
                    label: labels
                  });
                }
              }
            }
